# 2.4 Custom Functions, Page Objects, and Actions

## 2.4.1 You've Got Me Hooked

If you recall from the previous chapter, at the beginning we had set out to write three tests. They were: 

```js
// Login Page:
// should let you log in
// should error with a missing username
// should error with a missing password
```

We completed the first, but haven't touched the other two. Let's get to that now.

Both tests are very similar. In fact, they're almost like the first test we wrote, except we will be omitting certain steps and validating the page didn't change.

Using the "test comments" practice we used in our first test, here's what our two tests will do:

```js
// - go to the login page
// - enter either a valid username or a valid password into the corresponding input
// - click the 'Sign In' button
// - assert that correct error message is shown and we aren't logged in
```

If you remember, a couple of those steps are the same as what we've already coded. And if you're lazy like me, you don't want to code anymore than you already have to.

Well, let's avoid that extra work by moving our 'go to login page' step to a common location.

MochaJS provides a feature called "hooks" that allow you to run custom test code around your tests. Each `describe` block can have any or all of the following hooks implemented:

- before
- beforeEach
- afterEach
- after

`before` and `after` are run before/after the test suite. So if you have five tests, `before` would run before the set of tests, and `after` after the tests.

`beforeEach` and `afterEach`, however, execute around each test. Here's how the execution flow runs for a set of tests:

- before
- beforeEach
- test 1
- afterEach
- beforeEach
- test2
- afterEach
- after

As you can see, `beforeEach` and `afterEach` run multiple times based on the number of tests written. `before` and `after` only run at the start/end of the test suite.

Okay, enough explanation, let's see this in action. In our first test, we load the login page by running `await browser.url('./login');`. This is the code we're going to move to our hook.

Should we use a `before` or `beforeEach` hook though? That's a good question to ask, because there are benefits/drawbacks to each. The benefit to using a `beforeEach` hook is that we can be sure our page is "fresh" for our test. Changes made in a previous test won't impact this one (mostly... sometimes this isn't true). 

On the other hand, because `beforeEach` runs for every test, every step you take in it requires one more command to be run, extending the test execution time.

For us, the decision here is pretty easy. We're going to go with a `beforeEach` hook because we definitely need a fresh page for each of our tests (we don't want an error from our `missing username` test to contaminate our `missing password` test.

With that, let's move our step over. This is what the code looks like:

{title="test/specs/login.js"}
```js
describe('Login Page', function () {
    beforeEach(async function () {
        // go to the login page
        await browser.url('./login');
    });

    it('should let you log in', async function () {
        // enter a valid username in the "email" input
        await $('input[type="email"]').setValue('demo@learnwebdriverio.com');

        // enter a valid password in the "password" input
        await $('input[type="password"]').setValue('wdiodemo');

        // get the 'Sign in' button element reference
        const $signIn = $('button*=Sign in');

        // click the 'Sign in' button
        await $signIn.click();

        // wait for 'Your Feed' tab to appear, indicating we're logged in
        await $('=Your Feed').waitForDisplayed();

        // assert that we're logged in
        await expect($('.error-messages li')).not.toBeExisting();
    });

    // should error with a missing username
    // should error with a missing password
});
```

Not much has changed, but we've set ourselves up to do a little less work in the long run.

## 2.4.2 Getting the Error Text

As mentioned, there isn't much different between these two new tests we're writing and our previous test. That means I won't be covering what we've already talked about. So, on that note, here's what our two new tests are almost going to look like:

```js
it('should error with a missing username', async function () {
    await $('input[type="password"]').setValue('wdiodemo');

    await $('button*=Sign in').click();

    // assert that error message is showing
});

it('should error with a missing password', async function () {
    await $('input[type="email"]').setValue('demo@learnwebdriverio.com');

    await $('button*=Sign in').click();

    // assert that error message is showing
});
```

In our tests, we enter either the username or the password, but not both (to trigger showing an error message).

As you can see, the only work left to do is assert that the error message is showing. How do we go about this?

We have a couple of decent options:

- Re-use the error message selector we used in our first test (`$('.error-messages li')`), then validate using the `toHaveText` assertion to check our message.
- Use a 'text-based selector' to check for the specific error message (e.g., `$("li*=email can't be blank")`)

Using the second method, we'd combine our text-based selector with a `toBeExisting` assertion that runs after our test actions are executed. Here's what one test would look like:

```js
it('should error with a missing email', async function () {
    await $('input[type="password"]').setValue('wdiodemo');

    await $('button*=Sign in').click();

    // assert that error message is showing
    await expect($("li*=email can't be blank")).toBeExisting();
});
```

Wait, shouldn't we still have the `waitForExist` command that waits for the 'Sign in' button to disappear? No, because that button stays on the page when the login fails to complete. 

One drawback to this approach is, what if the error message does show, but the error text has slightly changed? Our test will fail and we'll be left thinking the login is completely broken (when really, it still validates correctly, it's just a different message).

Alternatively, using the first approach as mentioned, we can assert the text inside of the error message. While it will still throw an error if the message changes, we'll have a much better clue as to what's going on. 

We'll do this by using `toHaveText`, which uses the `getText` command behind the scenes to check the text of the element with the expected page.

The next two snippets of code are essentially the same:

```js
await expect($('.error-messages li')).toHaveText(`email can't be blank`);
// note the use of backticks due to the apostrophe in "can't"
```

```js
const errorText = await $('.error-messages li').getText();
expect(errorText).toEqual(`email can't be blank`);
```

As you can probably guess, `getText` gets the *visible* text of an element. Notice that I mentioned "visible." If the element is hidden, the `getText` command will return an empty string. 

A great example of this is an item in a dropdown menu. Since that item isn't visible until you open up the dropdown menu, `getText` will return an empty string. If you were to open up the dropdown menu, then run `getText`, it would successfully return the text value.

There is a workaround to this issue: The `getHTML` command. Just like `getText`, `getHTML` returns the HTML value of an element, including the text inside it. Do note that as of this writing, there is no `toHaveHTML` assertion to go alongside it.

Let's look again at the HTML for our error message:

```html
<ul class="error-messages">
  <li>email can't be blank</li>
</ul>
```

Assuming that all elements are visible, here's what our `getText` and `getHTML` commands would return:

```js
await $('.error-messages li').getText();
// returns "email can't be blank"

await $('.error-messages li').getHTML();
// returns "<li>email can't be blank</li>"

await $('.error-messages').getText();
// returns "email can't be blank"

await $('.error-messages').getHTML();
// returns "<ul class="error-messages"><li>email can't be blank</li></ul>"
```

First, notice how getting the text of the parent element returned the same value as getting the text of the individual element itself. That's by design, and you can use that knowledge to your advantage, so keep it in mind.

Second, the `getHTML` included the `<li>` tags in the response. It would be a more valid test if we ignored the HTML of the page and only returned the text content. We can do that!

`getHTML` accepts a single parameter, which is a boolean flag to include the selector element tag or not. By default it's `true`, and therefore includes that tag. If we pass in `false`, we get different results:

```js
await $('.error-messages li').getHTML(false);
// returns "email can't be blank"

await $('.error-messages').getHTML(false);
// returns "<li>email can't be blank</li>"
```

In the first command, now we get just the text without HTML. However, because that boolean flag only works on the main element, any child tags will still be included in the results, regardless of what we pass in. This means that `getHTML` still has its limitations, but I still like keeping the command in my back pocket for times when I need to get the text of a hidden element. 

Since our error message shouldn't be hidden, let's stick with the `getText` route. As mentioned before, we'll use the `toHaveText` assertion to achieve this. As an added benefit, because `toHaveText` automatically retries if it fails, we don't need to add any `waitFor` commands since it's essentially built-in to it:

```js
it('should error with a missing email', async function () {
    await $('input[type="password"]').setValue('wdiodemo');

    await $('button*=Sign in').click();

    // assert that error message is showing
    await expect($('.error-messages li')).toHaveText(`email can't be blank`);
});
```

Great, we now have a fully-built test ready for running.

## 2.4.3 Only One More Thing I Don't Want to Skip

Before running our test though, I want to talk about a quick tip with Mocha. There are two special abilities to it that make it easier to work on specific tests. 

Say we're working on a test, but it's failing and we don't really have time to fix it right now. Instead of deleting or commenting out the entire test, you can add `.skip` to either the `describe` or `it` function call, and it will skip the test. Here are some examples:

```js
describe('All tests', function () {
    it('will run', async function () {});

    it.skip('will be skipped', async function () {});

    describe.skip('Skipped Suite', function () {
        it('will be skipped', async function () {});
        it('will also be skipped', async function () {});
    });
});
```

Alternatively, say you only want to run a single test (or single set of tests). You can append `.only` to the `it` or `describe` function call to have only that test (and any other tests with `only` marked) run:

```js
describe('All tests', function () {
    it('will be skipped', async function () {});

    it.only('will run', async function () {});

    describe.only('Only Suite', async function () {
        it('will run', async function () {});
        it('will also run', async function () {});
    });
});
```

Notice how we can have multiple `only` tests and all of them marked as such will run? That's intentional, and you can use it to run only a few tests, instead of having to go in and run each test individually, moving the `.only` between them (or add `.skip` to all the tests you don't want running).

Okay, so we can use this new knowledge to run just the single new test that we've written. Here's what our updated file will look like:

{title="test/specs/login.js"}
```js
describe('Login Page', function () {
    beforeEach(async function () {
        // go to the login page
        await browser.url('./login');
    });

    it('should let you log in', async function () {
        // enter a valid username in the "email" input
        await $('input[type="email"]').setValue('demo@learnwebdriverio.com');

        // enter a valid password in the "password" input
        await $('input[type="password"]').setValue('wdiodemo');

        // get the 'Sign in' button element reference
        const $signIn = $('button*=Sign in');

        // click the 'Sign in' button
        await $signIn.click();

        // wait for 'Your Feed' tab to appear, indicating we're logged in
        await $('=Your Feed').waitForDisplayed();

        // assert that we're logged in
        await expect($('.error-messages li')).not.toBeExisting();
    });

    it.only('should error with a missing email', async function () {
        await $('input[type="password"]').setValue('wdiodemo');

        await $('button*=Sign in').click();

        // assert that error message is showing
        await expect($('.error-messages li')).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', async function () {
        await $('input[type="email"]').setValue('demo@learnwebdriverio.com');

        await $('button*=Sign in').click();

        // assert that error message is showing
    });
});
```

After running our `npx wdio --spec=login.js` command from the terminal again, you should see the green checkmark next to your passing test. It's always a good idea to make sure your assertion actually works, so try changing the expected text or commenting out the `click` command to validate the test fails if that error message doesn't show. 

Since the missing password test is so similar to the missing email test, I'm going to skip over explaining it and just post the test:

```js
it('should error with a missing password', async function () {
    await $('input[type="email"]').setValue('demo@learnwebdriverio.com');

    await $('button*=Sign in').click();

    // assert that error message is showing
    await expect($('.error-messages li')).toHaveText(`password can't be blank`);
});
```

## 2.4.4 Custom Test Functions

While we did some work to reduce repetition in our code so far by using the `beforeEach` hook, there's still more we can do. If you look at the first couple steps in all three tests, we do two things:

1. Fill out the form fields
2. Click the "Sign In" button

Shouldn't we move these to the `beforeEach` function? Well no, because the specifics in each individual test vary just enough for them to not fit a common `beforeEach` function.

Rather, we're going to create a custom function that will handle the unique parts of our login steps in a common way. This function will take an email and password value, then click the 'Sign in' button. We'll call this function from inside our tests. 

Here's what the function is going to look like:

```js
async function login(email, password) {
    await $('input[type="email"]').setValue(email);
    await $('input[type="password"]').setValue(password);

    await $('button*=Sign in').click();
}
```

We're using the exact code in our first test, so let's look at how that will look replaced:

```js
it('should let you log in', async function () {
    await login('demo@learnwebdriverio.com', 'wdiodemo');

    await $('button*=Sign in').waitForExist({ reverse: true });

    await expect($('.error-messages li')).not.toBeExisting();
});
```

In place of those commands, we call the `login` function, passing in our username and password values. This simplifies our test a bit, while keeping all the same functionality (although we do now have duplicate selectors for our 'Sign in' button, but we'll fix that soon). 

So what do we do for the other tests where we don't have a value for one of our fields? Well, we just pass in an empty string:

```js
it('should error with a missing username', async function () {
    await login('', 'wdiodemo');
    
    // assert that error message is showing
    await expect($('.error-messages li')).toHaveText(`email can't be blank`);
});
```

WebdriverIO will take that empty string and set the value of the corresponding field to it. It's technically an extra command being run, but it helps reduce repetition in our codebase so it's worth it.

Altogether, here's what the updates look like:

{title="test/specs/login.js"}
```js
async function login(email, password) {
    await $('input[type="email"]').setValue(email);
    await $('input[type="password"]').setValue(password);

    await $('button*=Sign in').click();
}

describe('Login Page', function () {
    beforeEach(async function () {
        // go to the login page
        await browser.url('./login');
    });

    it('should let you log in', async function () {
        await login('demo@learnwebdriverio.com', 'wdiodemo');

        await $('button*=Sign in').waitForExist({ reverse: true });

        await expect($('.error-messages li')).not.toBeExisting();
    });

    it('should error with a missing username', async function () {
        await login('', 'wdiodemo');

        // assert that error message is showing
        await expect($('.error-messages li')).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', async function () {
        await login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        await expect($('.error-messages li')).toHaveText(`password can't be blank`);
    });
});
```

So with this custom function, we've moved browser commands into a common area, reducing the redundancy of our code, which is good. That said, it's also made the codebase more complex. Instead of being able to find everything you need for a test within it, we now have to track down this `login` function and figure out what it does. 

As with all things programming, this is a tradeoff we make. Every step to reduce the verbosity of our tests increases the complexity of it. Be mindful of this as we move into the next section. Perhaps, for the sake of simplicity in a basic test suite, the following knowledge may be overdoing it in some circumstances. 

## 2.4.5 Basics of Page Objects

The function we built was pretty neat, and opens up the idea of moving implementation specifics outside the tests and into common areas more available for reuse. Page Objects build on that idea by providing a nomenclature for defining a page and the actions you can take on it. 

We defined a "login" function, but what if we could define the "login" page itself. The specific elements on that page, and the various actions you could take upon it. That's where Page Objects slide in.

Despite the "login" function reducing some code duplication, we still had to restate the `Sign in` button selector in our first test and the 'Error Message' selector in all three. Wouldn't it be nice if we could create a common area to store all of our element selectors? 

Well, a basic system would be to define each selector as a constant, then reference that constant in our tests:

```js
const emailSelector = 'input[type="email"]';
const passwordSelector = 'input[type="password"]';
const signInSelector = 'button*=Sign in';

async function login(email, password) {
    await $(emailSelector).setValue(email);
    await $(passwordSelector).setValue(password);

    await $(signInSelector).click();
}
```

This is an improvement, but it's only okay as far as code style goes. We still have to call the `$()` function a bunch, which makes the code a little bit more clunky. How about we switch those selectors to be element references?

```js
const $email = $('input[type="email"]');
const $password = $('input[type="password"]');
const $signIn = $('button*=Sign in');

function login(email, password) {
    await $email.setValue(email);
    await $password.setValue(password);

    await $signIn.click();
}
```

Isn't that better? No! It's much worse! If you tried running that code, you'd get several failures.

The reason is that we're trying to run the `$()` function outside its normal living space. Because the constants are defined outside the WebdriverIO context (which only exists within the specific Mocha functions), it errors out with a message of `Unable to load spec files quite likely because they rely on 'browser' object that is not fully initialised.`

So what we really need is "just-in-time" references. We want to store the code needed to get the element reference, but only run that code when we're inside our tests. What if we write some cute little functions that do that?

```js
const $email = function () {
    return $('input[type="email"]');
};
const $password = function () {
    return $('input[type="password"]');
};
const $signIn = function () {
    return $('button*=Sign in');
};

async function login(email, password) {
    await $email().setValue(email);
    await $password().setValue(password);

    await $signIn().click();
}
```

Okay, so that code works, but it sure is ugly. Having to call our element references as a function every time we want to access them? Certainly there's a cleaner way of achieving the same effect...

Surprise, there is! Okay... maybe it's not a surprise. I worked too hard to set myself up for all of this.

Regardless, newer versions of JavaScript let us achieve this with a much cleaner syntax. Using the `class` syntax (introduced in ECMAScript 2015 for those keeping track), we can define `get` functions that look like standard variables, but act like functions. 

First, we need to define a new `class` to hold all of our authentication related information:

```js
class Auth {
}
```

Then, we define our `get` functions inside it:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}
```

The `get` functions mirror our earlier element reference functions, so it should look familiar. But we don't access them by calling `Auth.$email()`. There is an extra step we need to take to make it all work.

When you define a `class`, you're stating how something "should" work. It's not the same as defining a variable or constant, which are able to be referenced right away. No, with a class, you first have to "instantiate" it.

Instantiate is a big fancy term meaning "the creation of a real instance or particular realization of an abstraction or template such as a class."

Not any clearer? Well, it basically means we're creating a new instance of something. In this case, it's the class we've just defined. We have to make an instance of it before putting it to work.

So we need to "instantiate" our class before we can use it. That's pretty easy:

```js
const auth = new Auth();
```

We call `new` on our Auth class like it's a function, and store it as an `auth` constant. Now we have a real reference that we can use in our test. 

Collectively, this is how our code now looks using classes:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}

const auth = new Auth();

async function login(email, password) {
    await auth.$email.setValue(email);
    await auth.$password.setValue(password);

    await auth.$signIn.click();
}
```

*Note: We don't need to include `async`/`await` in our `get` functions, as the `await` in our login function handles all of that. It's admittedly a little confusing and I don't really have a good explanation aside from "that's just how it works".*

We got rid of the function call for each of our element references, and prepended everything with our `auth` instantiated class. If you're counting text characters, we've actually gone up, but it's a lot cleaner and more self-documenting. All the elements related to authentication are stored inside the Auth instance. 

One added benefit of this approach is that we can use this `auth` instance throughout our tests. Here's what the fully updated test suite looks like:

{title="test/specs/login.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
}

const auth = new Auth();

async function login(email, password) {
    await auth.$email.setValue(email);
    await auth.$password.setValue(password);

    await auth.$signIn.click();
}

describe('Login Page', function () {
    beforeEach(async function () {
        // go to the login page
        await browser.url('./login');
    });

    it('should let you log in', async function () {
        await login('demo@learnwebdriverio.com', 'wdiodemo');

        await auth.$signIn.waitForExist({ reverse: true });

        await expect(auth.$errorMessages).not.toBeExisting();
    });

    it('should error with a missing username', async function () {
        await login('', 'wdiodemo');

        // assert that error message is showing
        await expect(auth.$errorMessages).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', async function () {
        await login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        await expect(auth.$errorMessages).toHaveText(`password can't be blank`);
    });
});
```

Notice how the tests themselves no longer store the selector information. All of those details are inside our page object. This [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns) helps reduce maintenance efforts (fewer places to change things) and improves readability. Instead of our test code being cluttered with selectors, they have more understandable references.

## 2.4.6 Naming Patterns

Speaking of which, how should you name your variables? Overall, that's an individual/team choice, but there are a few things you'll want to consider.

One option is to include the element type in the variable name (e.g., `$emailInput`, `$passwordInput`). While it's nice to know we're working with an input element, there are couple drawbacks to this approach:

1. It's more verbose. You can remediate this by using shorter names: `inp` vs `input` or `lbl` instead of `label`. But that can be confusing to folks unfamiliar with the nomenclature. 
2. Not all elements line up nicely with an element name. For example, container elements. Are you going to name it `accordionContainer` or `accordionDiv`? Are you going to name a list as `todoList` or `todoUl`?

I'm not saying including element information is a bad idea, only that you need to be consistent with your naming pattern.

Another consideration is how you'll name types of components. For example, if you're testing a to-do list, you might have the following HTML:

```html
<ul>
    <li>Item 1</li>
    <li>Item 2</li>
</ul>
```

Here's what the page object may look like:

```js
class TodoList {
    get $container () { return $('ul'); }
    get $$items () { return $$('li'); }
}
```

But it could also be:

```js
class TodoGroup {
    get $parent () { return $('ul'); }
    get $$tasks () { return $$('li'); }
}
```

Both are valid and work well, but the naming scheme is definitely different between the two. Inconsistent naming patterns can cause confusion for newcomers to the codebase, so be clear with the pattern you define from the start.

## 2.4.7 Page Actions

We were able to move our selectors out of our tests and into our page object; can we do the same with the login function? It's technically part of our "Auth" flow, and it would be great to group it inside of our Auth page object for reuse across our tests.

Yes, we certainly can move it, and that's just what we're going to do next. 

JavaScript classes, which are what we've been using so far to define our page object, allow you to define functions on them (as well as the 'getters' we've already used for our element references). You add these functions in a similar format to normal functions that live in the wild.

Instead of declaring our function on its own, we include it inside the curly braces that define our class. Let's update our class to declare a "login" function:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }
    
    async login (email, password) {
        // login actions go here
    }
}

const auth = new Auth();
```

I didn't include the steps in the function yet, as there's a slight tweak we need to make to the login code. Recall how the login function referenced the `auth` instance we created. For example: `auth.$signIn.click()`

If we try a straight copy/paste of that, the code will run successfully, but a bug will be lurking beneath the surface. 

When our function commands reference `auth`, they're talking about the specific `auth` instance that's later created in our code. Our page object has no real control over what this instance is named, so any changes to that name will break the code.

For instance, if the instantiation is changed to `const authentication = new Auth();`, our login function will error out with `auth is not defined`, as `auth` no longer exists. This means our function is brittle and likely to break with outside code changes. It's a bad situation to put yourself in.

How do we work around this issue? Well, conveniently, JavaScript classes give us a pre-defined `this` keyword that we can use to reference any instance of our class. We don't need to declare it anywhere, it exists as part of the normal runtime. Similar to how we don't define a `browser`, it already exists when we run our code.

JavaScript `this` can be a bit confusing, and we'll get into scenarios in the future where that's true. In our code right now though, just imagine that `this` is a reference to the overall class. Let's add the commands into our function, replacing `auth` with `this` as necessary:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    async login (email, password) {
        await this.$email.setValue(email);
        await this.$password.setValue(password);

        await this.$signIn.click();
    }
}
```

Now the `const auth = new Auth();` instantiation can be named anything and our code will still work. By using the magic of `this`, we alleviate the need to know what our instance will be named.

There's one last item to complete in our transition to page actions: we need to update our `login` reference in our test code. Since we want to call the `login` function that belongs to our `auth` instance, we can refer to it in the same way we've accessed our element reference: by prepending the instance name (i.e., `auth`) to our function name. 

So:

```js
await login('demowdio@example.com', 'wdiodemo');
```

becomes:

```js
await auth.login('demowdio@example.com', 'wdiodemo');
```

Now when we run the code, it will look for the `login` function on the `auth` page object instance. Here's what the entire file now looks like:

{title="test/specs/login.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    async login (email, password) {
        await this.$email.setValue(email);
        await this.$password.setValue(password);

        await this.$signIn.click();
    }
}

const auth = new Auth();

describe('Login Page', function () {
    beforeEach(async function () {
        // go to the login page
        await browser.url('./login');
    });

    it('should let you log in', async function () {
        await auth.login('demo@learnwebdriverio.com', 'wdiodemo');

        await auth.$signIn.waitForExist({ reverse: true });

        await expect(auth.$errorMessages).not.toBeExisting();
    });

    it('should error with a missing username', async function () {
        await auth.login('', 'wdiodemo');

        // assert that error message is showing
        await expect(auth.$errorMessages).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', async function () {
        await auth.login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        await expect(auth.$errorMessages).toHaveText(`password can't be blank`);
    });
});
```

We've now fully built-out our page object with element references and custom functions. This framework will be used throughout our tests moving forward, so you'll be prepared to see a lot of this. It might feel a bit over-complicated right now, but it opens up opportunities for extension in the future that we'll be covering in the next chapter. 

## 2.4.8 Improving Our Login Detection

We've gotten rid of the code duplication between our tests, but there's one final step we can take to reduce future duplication. When we login, we have a `waitForExist` command that pauses execution until the page has updated (i.e., `auth.$signIn.waitForExist({ reverse: true });`). Right now we're only using it once, but we'll be using this login function a lot in the future when we tests pages that require user login. 

But we can't just move that `waitForExist` command into our login function, because then our other two tests will fail as the `Sign in` button never disappears in those flows. How do we get around this?

I mentioned the `waitUntil` function a while back; now it's time to take advantage of it. 

As I mentioned, in our three tests, there are two different conditions we wait for:

Either:

1. For the login button to stop existing: `auth.$signIn.waitForExist({ reverse: true });`
2. For an error message to exist: `auth.$errorMessages.waitForExist();`

On the outside, it doesn't make sense to combine these, as one is for a successful login and the other is for a failed login. But what if we could say, "Wait for either this *or* that?"

This is where a custom `waitUntil` command comes in. It's your universal weapon if you want to wait on some specific scenario. It expects a condition and waits until that condition is fulfilled with a truthy value. 

With it, we can say, "Wait for the login button to disappear or for an error message to exist." To use the `waitUntil` method, call it and pass in a function that returns a true or false value, depending if the condition is met. WebdriverIO will keep waiting/calling that function until it either returns true, or reaches the timeout limit. 

For our login method, we can write our function as follows:

```js
await browser.waitUntil(async function () {
    const signInExists = await auth.$signIn.isExisting();
    const errorExists = await auth.$errorMessages.isExisting();

    return !signInExists || errorExists;
});
```

Our return statement will return true for either of the following conditions (`||` means 'or', if you're not familiar with it):

- The 'Sign in' button no longer exists (`!` reverses the value of `signInExists`)
- An error exists

Because `waitUntil` automatically retries, our function will continue to return false until either of those conditions is met (checking every half a second by default). If that condition isn't met by our `waitForTimeout` amount, it will fail saying `waitUntil condition timed out after 10000ms`.

Well, that message isn't very helpful. We know that `waitUntil` failed, but unless you were expecting the failure (which you likely weren't), you're going to have to dig in the code to figure out what condition it was. 

We can help that by passing in a custom error message. The `waitUntil` function signature looks like: 

```js
await browser.waitUntil(condition, { timeout, timeoutMsg, interval });
```

The `condition` is our function, which is required. After that is an options object. This object is almost the same as what we have for `waitForExist` (`reverse` isn't included, as it's not needed).

The `timeoutMsg` option is the custom error message we want to show in case of failure. We can leave out the rest so they'll go with the defaults.

Here's what this looks like:

```js
await browser.waitUntil(
    async function () {
        const signInExists = await auth.$signIn.isExisting();
        const errorExists = await auth.$errorMessages.isExisting();

        return !signInExists || errorExists;
    },
    { timoutMsg: 'The "Sign in" button still exists and an error never appeared' }
);
```

Perfect! Now we can remove that `waitForExist` statement in our test code and add our new `waitUntil` function to our `login` function:

```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    async login (email, password) {
        await this.$email.setValue(email);
        await this.$password.setValue(password);

        await this.$signIn.click();

        await browser.waitUntil(
            async () => {
                const signInExists = await this.$signIn.isExisting();
                const errorExists = await this.$errorMessages.isExisting();

                return !signInExists || errorExists;
            },
            { timoutMsg: 'The "Sign in" button still exists and an error never appeared' }
        );
    }
}
```

Two important things to point out that I changed here.

1. I updated `auth.` to `this.` So `auth.$signIn.isExisting()` is now `this.$signIn.isExisting()`. That's inline with the changes we made earlier.
2. I used a `fat arrow` function definition, instead of the previous `function () {}`. That's because our `waitUntil` function will be called with a different `this` value if we don't use it.

Remember how I said `this` can be tricky? Well, here's your example. If we used the following code...

```js
await browser.waitUntil(
    async function () {
        const signInExists = await this.$signIn.isExisting();
        const errorExists = await this.$errorMessages.isExisting();

        return !signInExists || errorExists;
    },
    { timoutMsg: 'The "Sign in" button still exists and an error never appeared' }
);
```

...the `this` in our code wouldn't refer to our page object, but rather the WebdriverIO `browser` instance (so it would be the same as calling `browser.$signIn.isExisting()`, which doesn't work). By using a fat arrow function, we bind `this` to the page object, allowing us to say `this.$signIn.isExisting();`. 

For more details on fat arrow functions, have a read through [this in-depth article by Mozilla](https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/).

Here's what our fully updated `login.js` file looks like:

{title="test/specs/login.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    async login (email, password) {
        await this.$email.setValue(email);
        await this.$password.setValue(password);

        await this.$signIn.click();

        await browser.waitUntil(
            async function () {
                const signInExists = await this.$signIn.isExisting();
                const errorExists = await this.$errorMessages.isExisting();

                return !signInExists || errorExists;
            },
            { timoutMsg: 'The "Sign in" button still exists and an error never appeared' }
        );
    }
}

const auth = new Auth();

describe('Login Page', function () {
    beforeEach(async function () {
        // go to the login page
        await browser.url('./login');
    });

    it('should let you log in', async function () {
        await auth.login('demo@learnwebdriverio.com', 'wdiodemo');

        await expect(auth.$errorMessages).not.toBeExisting();
    });

    it('should error with a missing username', async function () {
        await auth.login('', 'wdiodemo');

        // assert that error message is showing
        await expect(auth.$errorMessages).toHaveText(`email can't be blank`);
    });

    it('should error with a missing password', async function () {
        await auth.login('demo@learnwebdriverio.com', '');

        // assert that error message is showing
        await expect(auth.$errorMessages).toHaveText(`password can't be blank`);
    });
});
```

## 2.4.9: Separating Files

We've finished with our Page Object/Actions, but there's still one last thing to do. As we move forward with new tests, it will be really helpful to have this Auth page object available elsewhere. It's a very good idea to separate out your page objects from your test files, so let's do that. 

Grab all of your `class` code and move it to a new file that looks like:

{title="test/pageObjects/Auth.page.js"}
```js
class Auth {
    get $email () { return $('input[type="email"]'); }
    get $password () { return $('input[type="password"]'); }
    get $signIn () { return $('button*=Sign in'); }
    get $errorMessages () { return $('.error-messages li'); }

    async login (email, password) {
        await this.$email.setValue(email);
        await this.$password.setValue(password);

        await this.$signIn.click();

        await browser.waitUntil(
            async () => {
                const signInExists = await this.$signIn.isExisting();
                const errorExists = await this.$errorMessages.isExisting();

                return !signInExists || errorExists;
            },
            { 
                timoutMsg: 'The "Sign in" button still exists and an error never appeared'
            }
        );
    }
}

module.exports = Auth;
```

In addition to the moved code, at the very bottom, we added an 'export' for our class via Node's export system. We did this by attaching our class to the `module.export` value ([Node.js technical docs on `module.export`](https://nodejs.org/api/modules.html#modules_exports_shortcut)). Without this, our class wouldn't get exported from the file, which would be bad.

Now we need to save our file. First, we need a new folder to save our page object in. If we save it to our specs folder, WebdriverIO will think it's a test spec file and try running it as so. Instead, let's save it outside the `test/specs` folder, to a specific page objects folder at `test/pageObjects`.

For the filename, I like to use a leading capital letter, signifying that we've exported a single class. I also like to append `.page` in my filename, to let others know that this is a page object definition. So my filename will be saved to `test/pageObjects/Auth.page.js`.

Finally, back in our test file, we need to import our page object for usage. This is what the top of the file will now look like:

```js
const Auth = require('../pageObjects/Auth.page');

const auth = new Auth();
```

With everything moved around and hooked up, you can run your tests one more time to ensure it's all plugged in correctly.

In the next chapter, we're going to use our new Auth page object to help ourselves get logged in, so we can test all sorts of authenticated functionality.

## 2.4.10 Chapter Challenge

- Write a set of tests for the register account page that checks the following requirements:
  - Requires username, email, and password
  - errors if username is already taken
  - errors if email is not a valid format (e.g., missing `@`)
  - errors if email has already been taken
  - Takes you to the home page once you register